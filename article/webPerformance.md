## web Performance
> 感觉工程化在一定程度上削弱了性能优化的着力点

性能优化有关的最佳实践具有很多现实意义。

- [Yahoo Rules](#yahoo-rules)
- [Best Practice](#best-practice)

### Yahoo Rules

雅虎的 14 条性能优化规则有个基本点：针对客户端用户的体验感知，前端优化比后端优化更重要。如果具体一些的话，我觉着前端主要是跟资源打交道，涉及资源的加载、解析和执行，其中最影响性能的是资源的加载，毕竟网络 I/O 通常是最慢的。

性能黄金法则也进一步提出，最终用户响应时间中只有 10% ~ 20% 来自页面的加载，剩下的 80% ~ 90% 都是页面中各种资源或者说组件的加载。

对雅虎的 14 条性能优化规则的理解大致如下：

1. **减少 HTTP 请求（make fewer HTTP requests）**：首次访问通常是无缓存的，因此减少 HTTP 请求十分重要。最基本的是合并脚本和样式，这也是前端工程构建最早触碰的点，早在 Gulp 时代就已经出现了。除了脚本和样式，剩下的大多是图片，但图片地图和 CSS sprites 其实很少用了，更多的可能是字体图标。此外，使用基本 base64 的 data: url 内联图片也偶尔会用到。
2. **使用内容发布网络（use a content delivery network）**：毕竟 CDN 也是服务器，相当于强化了 HTTP 的响应能力。如果用户量激增时，把静态资源放在 CDN 上效果可能会很不错。
3. **添加 Expires 头（add an Expires header）**：磁盘 I/O 比网络 I/O 快一个数量级，能缓存的资源尽量去缓存。但如果突然想提供最新的资源，最好能采用修改版本号或添加时间戳的方式，不能依赖让用户主动清空缓存。
4. **压缩组件（gzip components）**：gzip 是对数据进行编码，比单纯的 minify 要厉害很多。经过 minify 的资源可能会减少百分之几十的体积，但经过 gzip 后通常是降低一个数量级。所以可以对样式和脚本进行 gzip，毕竟现在浏览器都支持 gzip 解码。
5. **将样式表放在顶部（put stylesheets at the top）**：渲染引擎是对构建出的 render tree 进行渲染，如果样式迟迟未被解析，dom tree 只能黯然神伤，如果还有一堆其他资源抢在样式表之前加载，那 render tree 的构建就更是遥遥无期。把样式表放在顶部会让构建和渲染同步进行，用户也能早点看到内容，即使不够完整。
6. **将脚本放在底部（put scripts at the bottom）**：脚本的加载和执行默认会阻塞页面中其他的资源加载和解析，靠前的脚本将影响整个页面的渲染，所以把脚本后置是最好。如果使用 async 或 defer 脚本则会异步加载，不会阻塞页面解析，可以根据依赖关系来选择。
7. **避免 CSS 表达式（avoid CSS expression）**：个人感觉 CSS 表达式有些越界，很多使用场景也没有必要。
8. **使用外部 JavaScrip 和 CSS（make JavaScript and CSS external）**： 访问页面不是一锤子买卖，采用外部的资源文件才能触发缓存。其实跟第一点结合的话会有新的意义：请求数目与资源数目是正相关的，而稳定的资源数目与缓存数目是正相关的。
9. **减少 DNS 查询（reduce DNS lookups）**：所有资源加载前都要有 DNS 查询，主机名过多会增加 DNS 查询的负担，主机名过少会浪费并行下载的机会。好在 DNS 通常有本地缓存，而且本身的时间消耗并不多，所以一般不太重要。
10. **精简 JavaScript（minify JavaScript）**：脚本的 minify 主要是删除空白和注释，能够在 gzip 前先对文本进行一轮瘦身，这在工程构建中属于基本流程了。另外，如果平时有不写分号的习惯也会对性能有一点微小的贡献。
11. **避免重定向（avoid redirects）**：重定向会额外增加一次 HTTP 请求。如果不是出于重要目的，就尽可能的避免。如果是为了美化提供给用户的 URL，完全可以采用二级域名。好心的浏览器只负责填充主机名后面缺少的斜杠，如果是为了偷懒少写斜杠，就得承担一次重定向成本。
12. **删除重复脚本（remove duplicate scripts）**：尽管浏览器通常会避免此类情况下的重复请求和重复执行，但包含有相同的脚本还是太蠢了。合理的团队沟通和工程构建都能避免这种问题的出现。
13. **配置 ETag（configure ETags）**：目前还没接触过，感觉一般也用不到。
14. **使 Ajax 可缓存（make Ajax cacheable）**：或许这个主要指异步请求数据也要遵循基本法，比如使用时减少 DNS 查询和避免重定向。

### Best Practice

web 性能优化其实只是项目开发中的一小部分，而且质量、成本和时间通常只能满足两个。各个因素之间的权衡（trade off）要求我们在考虑优化时，最好先评估各个模块的开销，然后再决定优化哪个部分能够取得最大的收益。有时候我们习惯性认为脚本质量是性能瓶颈，但实际的罪魁祸首可能是 DOM 操作和布局渲染。

如果不考虑 Web Worker 的话，JS 在浏览器中是运行在单线程上，各种基于事件和回调的 API 通过 Event Loop 机制实现异步。为了保证浏览器能够及时响应用户交互，主线程上应该尽可能少的出现计算量过大的操作。通常操作延迟大于 0.1 秒就会被用户感知到，如果超过 1 秒就会被认为缓慢，而如果超过了 10s，用户的耐心就会消磨殆尽。

渲染初始页面通常不需要所有的脚本。需要在 onload 事件触发前执行的脚本很有限，如果能够把页面初始化过程并不执行的脚本的加载过程延后，将会提高页面的初始化速度。

to be continued...

### 参考
1. [高性能网站建设指南 - Steve Souders](https://book.douban.com/subject/26411563/)
2. [高性能网站建设进阶指南 - Steve Souders](https://book.douban.com/subject/26411563/)
